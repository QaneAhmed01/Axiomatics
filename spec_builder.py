from apispec import APISpec
import yaml 
from typing import Dict, Any
import re 

def build_openapi(agent_output: Dict[str, Any], title: str = "Generated API", version: str= "1.0.0") -> Dict:
    spec = APISpec(
        title=title,
        version=version,
        openapi_version="3.0.3",
        info={"description": "API generated by Ai assistant"},
        plugins=[] ) #Creating an empty APISpec object 

    schemas=agent_output.get("schemas", {})
    if schemas:
        spec.components.schema("GeneratedSchemas",schema={}) #Register empty schema container
        pass 

    spec_dict={ 
        "openapi": "3.0.3",
        "info":{"title": title, "version":version,"description":"API generated by Ai assistant"},
        "paths":{},
        "components":{"schemas":{}}
    }# Starting the root OpenAPI dict

    for name, schema in agent_output.get("schemas",{}).items():
        spec_dict["components"]["schemas"][name]=schema #Adding the generated schemas

    for e in agent_output.get("endpoints", []):
            path = e["path"] #Get endpoint path
            method = e["method"].lower()# Convert the HTTP method to lowercase

            # Ensure path entry exists
            if path not in spec_dict["paths"]:
                spec_dict["paths"][path] = {} #Making sure the path exists

            op = {
                "summary": e.get("description", ""), #End point description
                "responses": {} # Preparing a response container 
            }

            param_names = re.findall(r"{([^}]+)}", path) #Extract path parameters
            if param_names:
                op["parameters"] = [] #Creating the parameters list
                for name in param_names:
                    op["parameters"].append(
                        {
                            "name": name,
                            "in": "path",
                            "required": True,
                            "schema": {"type": "string"},
                        }
                    ) #Adding a parameter spec 

            # --- Responses ---
            for status, desc in (e.get("responses") or {}).items():
                # If the LLM gave a schema-like object (dict), wrap it as a proper response
                if isinstance(desc, dict):
                    op["responses"][str(status)] = {
                        "description": "Success" if str(status).startswith("2") else "Response",
                        "content": {
                            "application/json": {
                                "schema": desc
                            }
                        }
                    } #JSON response with schema
                else:
                    # Plain string description
                    op["responses"][str(status)] = {  "description": desc} #Making so it only is text response

            if e.get("requestBody"):
                op["requestBody"] = {
                    "content": {
                        "application/json": {
                            "schema": e["requestBody"]
                        }
                    }
                }

            spec_dict["paths"][path][method] = op #Attaching a operation to path/method

    return spec_dict #Returning the final OpenAPI dictionary

def save_spec_yaml(spec_dict:Dict, out_path:str):
    with open(out_path,"w") as f:
        yaml.safe_dump(spec_dict, f, sort_keys=False) #Just saving it as YAML